---
layout: article
title: 쉘기능을 자유자재로 다루기_07 이식성을 고려한 외부 명령어 이용하기
tags: [Linux, ShellScript, uname, echo]
key: 20240307-linux-uname-echo
---

- 출처 : 유닉스 리눅스 쉘스크립트 예제사전_한빛미디어

> 명령어: uname, echo  
> 키워드: 범용성, 이식성, OS  
> 사용처: OS마다 명령어 동작이 달라 각각 명령어를 변수로 정의하고 싶을 때

--- 
 
> 실행예제

```
$ ./os-command.sh
이것은 줄이 이어진 메시지 입니다.
```

> 스크립트

```bash
#!/bin/sh

# echo 명령어 경로를 환경에 따라서 바꿔서 셸 변수 ECHO에 대입
case $(uname -s) in
    # Mac 이면 셸 내장이 아니라 bin/echo 사용
    Darwin)
      ECHO="/bin/echo"
      ;;
    *)
      ECHO="echo"
      ;;
esac

$ECHO -n "이것은 줄이 이어진 "
$ECHO "메시지 입니다."
```

&nbsp;
&nbsp;

## **해설**

이 스크립트는 echo 명령어를 셸 변수 ECHO로 치환합니다. **Mac echo 명령어는 줄을 바꾸지 않는 -n 옵션에 대응하지 않으므로** 그럴 때 대응하는 방법입니다.

Mac 셸 내장 echo 명령어는 -n 옵션이 없으므로 리눅스에서 스크립트를 가져올 때는 echo -n 부분을 전수 수정해야 합니다. 따라서 그런 번거로움을 줄이고 범용성을 높이기 위한 것이 이 예제입니다.

셸 스크립트로 어떤 명령어를 변수명으로 치환한다면 그 명령어의 대문자 표기를 변수명으로 자주 사용합니다. 이것은 관습적인 것으로 기술적 이유가 있는 것은 아닙니다. 하지만 다른 사람이 작성한 스크립트를 읽을 때 이런 표현이 나올 때가 있으므로 기억해두면 좋습니다. 예제에서는 echo 명령어를 치환하므로 셸 변수 ECHO를 사용합니다.

우선 OS를 알아내기 위해 `1`{:.info}에서는 case문 인수로 uname 명령어를 실행합니다. **uname 명령어**는 시스템 정보를 표시하는 명령어로 OS 명칭을 표시하려면 -s 옵션을 사용합니다. 실제로 표시되는 문자열은 다음과 같습니다.

- OS별 uname 명령어 표시

  |OS|uname -s 출력|
  |:-|:-----------|
  |Linux|Linux|
  |FreeBSD|FreeBSD|
  |MacOS|Darwin|
  |Solaris|SunOS|

`2`{:.info}는 Mac(Darwin)이라면 셸 변수 ECHO에 **/bin/echo**를 지정해서 셸 내장 echo가 아니라 외부 명령어 /bin/echo를 사용하게 됩니다. 그 외 OS는 그대로 echo 명령어를 실행하고 싶으므로 셸 변수 ECHO에 echo를 입력합니다.

이렇게 해서 환경별 echo 명령어가 준비되면 `3`{:.info}에서 실행합니다. 이런 식으로 명령어를 변수로 치환하고 새롭게 정의한 변수를 명령어처럼 사용해서 스크립트를 작성합니다. 여기서 첫 번째 줄이-n으로 실행되므로 개행되지 않습니다. 실행 예처럼 다음 echo 명령어 출력도 이어서 표시됩니다. OS마다 명령어 행동이 조금 달라도 같은 스크립트로 여러 OS에 대응하는 스크립트를 작성할 수 있습니다.

&nbsp;
&nbsp;

## **주의사항**

- 범용성을 중시하면 스크립트가 복잡해집니다. 이 예를 보면 echo 명령어 하나 때문에 이렇게까지 해야 하나 싶을 수도 있습니다. 사실 너무 범용성을 중시하다 보면 스크립트가 복잡해져서 본말전도됩니다. 하지만 이런 OS 범용성을 중시하는 스크립트는 오픈 소스 계열에 많으므로 알아두면 좋습니다.

- gzip 명령어는 환경 변수 GZIP이 기본 옵션으로 상요되므로 예제에서 사용하는 방법을 쓸 때 주의해야 합니다.
